RealSinc.java~INTERFACE=Sinc~BODY=@Override\npublic O compute(I input, O output) {\n    double x = input.getRealDouble();\n    double value;\n    if (x == 0) value = 1; else value = Math.sin(x) / x;\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the sinc value of\n * the real component of an input real number. The sinc function is defined\n * as sin(x) / x.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealFloor.java~INTERFACE=Floor~BODY=@Override\npublic O compute(I x, O output) {\n    output.setReal(Math.floor(x.getRealDouble()));\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the floor of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealArccsch.java~INTERFACE=Arccsch~BODY=@Override\npublic O compute(I x, O output) {\n    double xt = x.getRealDouble();\n    double delta = Math.sqrt(1 + (1 / (xt * xt)));\n    double value = Math.log((1 / xt) + delta);\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse hyperbolic\n * cosecant of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealSec.java~INTERFACE=Sec~BODY=@Override\npublic O compute(I x, O output) {\n    double value = 1.0 / Math.cos(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the secant of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealCopy.java~INTERFACE=Copy~BODY=@Override\npublic O compute(I x, O output) {\n    output.setReal(x.getRealDouble());\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the real component of\n * an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealOrConstant.java~INTERFACE=OrConstant~BODY=private final long constant;\npublic RealOrConstant(long constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    long value = constant | (long) x.getRealDouble();\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the logical OR of\n * the real component of an input real number with a constant value. The\n * constant value is specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealUnaryOperation.java~INTERFACE=UnaryOperation~BODY=~JAVADOC=/**\n * A {@link UnaryOperation} between {@link RealType}s.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealCot.java~INTERFACE=Cot~BODY=@Override\npublic O compute(I x, O output) {\n    double value = 1.0 / Math.tan(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the cotangent of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealExp.java~INTERFACE=Exp~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.exp(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the exponentiation of\n * the real component of an input real number. (e raised to a power)\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealCosh.java~INTERFACE=Cosh~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.cosh(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the hyperbolic cosine\n * of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealSqr.java~INTERFACE=Sqr~BODY=@Override\npublic O compute(I x, O output) {\n    double value = x.getRealDouble();\n    output.setReal(value * value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the square of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealArctanh.java~INTERFACE=Arctanh~BODY=@Override\npublic O compute(I x, O output) {\n    double xt = x.getRealDouble();\n    double value = 0.5 * Math.log((1 + xt) / (1 - xt));\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse hyperbolic\n * tangent of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealNearestInt.java~INTERFACE=NearestInt~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.rint(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the nearest\n * integral value of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealSinh.java~INTERFACE=Sinh~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.sinh(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the hyperbolic sine of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealUlp.java~INTERFACE=Ulp~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.ulp(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the size of the ulp\n * of an input real number. An ulp of a floating point value is the positive\n * distance between an input floating-point value and the floating point value\n * next larger in magnitude. Note that for non-NaN x, ulp(-x) == ulp(x).\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealAndConstant.java~INTERFACE=AndConstant~BODY=private final long constant;\npublic RealAndConstant(long constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    long value = constant & (long) x.getRealDouble();\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the logical AND of\n * the real component of an input real number with a constant value. The\n * constant value is specified in the constructor.\n *\n * @author Barry DeZonia\n */\n~IMPORTS= 
RealSincPi.java~INTERFACE=SincPi~BODY=@Override\npublic O compute(I input, O output) {\n    double x = input.getRealDouble();\n    double value;\n    if (x == 0) value = 1; else value = Math.sin(Math.PI * x) / (Math.PI * x);\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the sinc (pi version)\n * of the real component of an input real number. The pi version of sinc is\n * defined as sin(x*pi) / (x*pi).\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealGaussianRandom.java~INTERFACE=GaussianRandom~BODY=private Random rng = new Random();\n@Override\npublic O compute(I x, O output) {\n    double value = rng.nextGaussian() * Math.abs(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to a random value using a\n * gaussian distribution. The input value is considered the standard deviation\n * of the desired distribution and must be positive. The output value has mean\n * value 0.\n * \n * @author Barry DeZonia\n */\n~IMPORTS=import java.util.Random;\n
RealCsch.java~INTERFACE=Csch~BODY=@Override\npublic O compute(I x, O output) {\n    double value = 1.0 / Math.sinh(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the hyperbolic\n * cosecant of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealAbs.java~INTERFACE=Abs~BODY=@Override\npublic O compute(I x, O output) {\n    output.setReal(Math.abs(x.getRealDouble()));\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the absolute value of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealSin.java~INTERFACE=Sin~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.sin(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the sine of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealLog2.java~INTERFACE=Log2~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.log(x.getRealDouble()) / Math.log(2);\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the base 2\n * log of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealRound.java~INTERFACE=Round~BODY=@Override\npublic O compute(I x, O output) {\n    output.setReal(Math.round(x.getRealDouble()));\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the rounding of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealGammaConstant.java~INTERFACE=GammaConstant~BODY=private final double constant;\npublic RealGammaConstant(double constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    double inputVal = x.getRealDouble();\n    if (inputVal <= 0) output.setReal(0); else {\n        double value = Math.exp(this.constant * Math.log(inputVal));\n        output.setReal(value);\n    }\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the gamma value of\n * the real component of an input real number. The constant value is\n * specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealLog.java~INTERFACE=Log~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.log(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the natural\n * log of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealLogOnePlusX.java~INTERFACE=LogOnePlusX~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.log1p(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the natural logarithm\n * of the sum of the argument and 1. This calculation is more accurate than\n * explicitly calling log(1.0 + x).\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealExpMinusOne.java~INTERFACE=ExpMinusOne~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.exp(x.getRealDouble()) - 1;\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to e^x - 1. x is the\n * input argument to the operation.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealArccos.java~INTERFACE=Arccos~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.acos(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse cosine of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealXorConstant.java~INTERFACE=XorConstant~BODY=private final long constant;\npublic RealXorConstant(long constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    long value = constant ^ (long) x.getRealDouble();\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the logical XOR of\n * the real component of an input real number with a constant value. The\n * constant value is specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealArcsinh.java~INTERFACE=Arcsinh~BODY=@Override\npublic O compute(I x, O output) {\n    double xt = x.getRealDouble();\n    double delta = Math.sqrt(xt * xt + 1);\n    double value = Math.log(xt + delta);\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse hyperbolic\n * sine of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealCoth.java~INTERFACE=Coth~BODY=@Override\npublic O compute(I x, O output) {\n    double value = 1.0 / Math.tanh(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the hyperbolic\n * cotangent of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealZero.java~INTERFACE=Zero~BODY=@Override\npublic O compute(I x, O output) {\n    output.setZero();\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to zero.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealCsc.java~INTERFACE=Csc~BODY=@Override\npublic O compute(I x, O output) {\n    double value = 1.0 / Math.sin(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the cosecant of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealConvert.java~INTERFACE=Convert~BODY=public enum TypeConversionTypes {\n\n    DIRECTCLIP, SCALE, DIRECT, SCALECLIP\n}\nprivate final TypeConversionTypes m_mode;\nprivate double m_inMin;\nprivate final double m_outMax;\nprivate double m_outMin;\nprivate double m_factor;\nprivate final I m_inType;\nprivate final O m_outType;\nprivate final UnaryOperation<I, O> m_op;\n/**\n	 * Convert to the new type.\n	 * \n	 * @param inType\n	 *            The old type.\n	 * @param outType\n	 *            The new type.\n	 */\npublic Convert(final I inType, final O outType, TypeConversionTypes mode) {\n    m_outType = outType;\n    m_mode = mode;\n    m_op = initOp();\n    m_inType = inType;\n    m_inMin = inType.getMinValue();\n    m_outMax = m_outType.getMaxValue();\n    m_outMin = m_outType.getMinValue();\n    if (mode == TypeConversionTypes.SCALE || mode == TypeConversionTypes.DIRECTCLIP) {\n        m_factor = (inType.getMaxValue() - m_inMin) / (outType.getMaxValue() - m_outMin);\n    } else {\n        m_factor = 1.0;\n    }\n}\npublic void setOutMin(double outMin) {\n    m_outMin = outMin;\n}\npublic void setInMin(double inMin) {\n    m_inMin = inMin;\n}\npublic double getFactor() {\n    return m_factor;\n}\npublic void setFactor(double newFactor) {\n    m_factor = newFactor;\n}\nprivate UnaryOperation<I, O> initOp() {\n    switch(m_mode) {\n        case DIRECTCLIP:\n            return new UnaryOperation<I, O>() {\n\n                private double v;\n\n                @Override\n                public O compute(I op, O r) {\n                    v = op.getRealDouble();\n                    if (v > m_outMax) {\n                        r.setReal(m_outMax);\n                    } else if (v < m_outMin) {\n                        r.setReal(m_outMin);\n                    } else {\n                        r.setReal(v);\n                    }\n                    return r;\n                }\n\n                @Override\n                public UnaryOperation<I, O> copy() {\n                    return this;\n                }\n            };\n        case DIRECT:\n            return new UnaryOperation<I, O>() {\n\n                @Override\n                public O compute(I op, O r) {\n                    r.setReal(op.getRealDouble());\n                    return r;\n                }\n\n                @Override\n                public UnaryOperation<I, O> copy() {\n                    return this;\n                }\n            };\n        case SCALE:\n            return new UnaryOperation<I, O>() {\n\n                @Override\n                public O compute(I op, O r) {\n                    r.setReal((op.getRealDouble() - m_inMin) / m_factor + m_outMin);\n                    return r;\n                }\n\n                @Override\n                public UnaryOperation<I, O> copy() {\n                    return this;\n                }\n            };\n        case SCALECLIP:\n            return new UnaryOperation<I, O>() {\n\n                private double v;\n\n                @Override\n                public O compute(I op, O r) {\n                    v = (op.getRealDouble() - m_inMin) / m_factor + m_outMin;\n                    if (v > m_outMax) {\n                        r.setReal(m_outMax);\n                    } else if (v < m_outMin) {\n                        r.setReal(m_outMin);\n                    } else {\n                        r.setReal(v);\n                    }\n                    return r;\n                }\n\n                @Override\n                public UnaryOperation<I, O> copy() {\n                    return this;\n                }\n            };\n    }\n    return null;\n}\n@Override\npublic final O compute(final I op, final O r) {\n    return m_op.compute(op, r);\n}\n@Override\npublic void convert(I input, O output) {\n    m_op.compute(input, output);\n}\n~JAVADOC=/**\n * @author Christian Dietz (University of Konstanz)\n * @author Martin Horn (University of Konstanz)\n *\n * @param <I>\n * @param <O>\n */\n~IMPORTS=import net.imglib2.converter.Converter;\n
RealDivideConstant.java~INTERFACE=DivideConstant~BODY=private final double constant;\nprivate final double dbzVal;\npublic RealDivideConstant(double constant, double dbzVal) {\n    this.constant = constant;\n    this.dbzVal = dbzVal;\n}\n@Override\npublic O compute(I x, O output) {\n    if (constant == 0) {\n        output.setReal(dbzVal);\n    } else {\n        double value = x.getRealDouble() / constant;\n        output.setReal(value);\n    }\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the division of\n * the real component of an input real number by a constant value. The\n * constant value is specified in the constructor. In the case of division\n * by zero the value is set to a value also specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealSignum.java~INTERFACE=Signum~BODY=@Override\npublic O compute(I x, O output) {\n    output.setReal(Math.signum(x.getRealDouble()));\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the signum of the real\n * component of an input real number. It equals -1 if the input number is less\n * than 0, it equals 1 if the input number is greater than 0, and it equals 0 if\n * the input number equals 0.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealConstant.java~INTERFACE=Constant~BODY=private final double constant;\npublic RealConstant(double constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    output.setReal(constant);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to a constant value. The\n * constant value is specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealSqrt.java~INTERFACE=Sqrt~BODY=@Override\npublic O compute(I x, O output) {\n    output.setReal(Math.sqrt(x.getRealDouble()));\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the square root of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealArcsec.java~INTERFACE=Arcsec~BODY=private final RealArcsin<DoubleType, DoubleType> asin = new RealArcsin<DoubleType, DoubleType>();\nprivate DoubleType angle = new DoubleType();\nprivate DoubleType tmp = new DoubleType();\n@Override\npublic O compute(I x, O output) {\n    double xt = x.getRealDouble();\n    if ((xt > -1) && (xt < 1)) throw new IllegalArgumentException("arcsec(x) : x out of range"); else if (xt == -1) output.setReal(Math.PI); else if (xt == 1) output.setReal(0); else {\n        tmp.setReal(Math.sqrt(xt * xt - 1) / xt);\n        asin.compute(tmp, angle);\n        double value = angle.getRealDouble();\n        if (xt < -1) value += Math.PI;\n        output.setReal(value);\n    }\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse secant of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS=import net.imglib2.type.numeric.real.DoubleType;\n
RealArccot.java~INTERFACE=Arccot~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.atan(1.0 / x.getRealDouble());\n    if (x.getRealDouble() < 0) value += Math.PI;\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse cotangent\n * of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealTanh.java~INTERFACE=Tanh~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.tanh(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the hyperbolic tangent\n * of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealAddNoise.java~INTERFACE=AddNoise~BODY=private final double rangeMin;\nprivate final double rangeMax;\nprivate final double rangeStdDev;\nprivate final Random rng;\n/**\n	 * Constructor specifying noise parameters.\n	 * @param min - the desired lower bound on the output pixel values\n	 * @param max - the desired upper bound on the output pixel values\n	 * @param stdDev - the stand deviation of the gaussian random variable\n	 */\npublic RealAddNoise(double min, double max, double stdDev) {\n    this.rangeMin = min;\n    this.rangeMax = max;\n    this.rangeStdDev = stdDev;\n    this.rng = new Random();\n    this.rng.setSeed(System.currentTimeMillis());\n}\n@Override\npublic O compute(I x, O output) {\n    int i = 0;\n    do {\n        double newVal = x.getRealDouble() + (rng.nextGaussian() * rangeStdDev);\n        if ((rangeMin <= newVal) && (newVal <= rangeMax)) {\n            output.setReal(newVal);\n            return output;\n        }\n        if (i++ > 100) throw new IllegalArgumentException("noise function failing to terminate. probably misconfigured.");\n    } while (true);\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the addition of\n * the real component of an input real number with an amount of Gaussian\n * noise. The noise parameters are specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS=import java.util.Random;\n
RealArccsc.java~INTERFACE=Arccsc~BODY=private static final RealArccos<DoubleType, DoubleType> acos = new RealArccos<DoubleType, DoubleType>();\nprivate DoubleType angle = new DoubleType();\nprivate DoubleType tmp = new DoubleType();\n@Override\npublic O compute(I x, O output) {\n    double xt = x.getRealDouble();\n    if ((xt > -1) && (xt < 1)) throw new IllegalArgumentException("arccsc(x) : x out of range"); else if (xt == -1) output.setReal(-Math.PI / 2); else if (xt == 1) output.setReal(Math.PI / 2); else {\n        tmp.setReal(Math.sqrt(xt * xt - 1) / xt);\n        acos.compute(tmp, angle);\n        output.setReal(angle.getRealDouble());\n    }\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse cosecant\n * of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS=import net.imglib2.type.numeric.real.DoubleType;\n
RealPowerConstant.java~INTERFACE=PowerConstant~BODY=private final double constant;\npublic RealPowerConstant(double constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    double value = Math.pow(x.getRealDouble(), constant);\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the raising of\n * the real component of an input real number to a constant value. The\n * constant value is specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealLog10.java~INTERFACE=Log10~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.log10(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the 10-based\n * log of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealMinConstant.java~INTERFACE=MinConstant~BODY=private final double constant;\npublic RealMinConstant(double constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    double value = x.getRealDouble();\n    if (value > constant) output.setReal(value); else output.setReal(constant);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the real component of\n * an input real number unless it is less then a minimum value. If it is less\n * than the minimum value then it sets the output real component to that minimum\n * value. The minimum value is specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealMaxConstant.java~INTERFACE=MaxConstant~BODY=private final double constant;\npublic RealMaxConstant(double constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    double value = x.getRealDouble();\n    if (value < constant) output.setReal(value); else output.setReal(constant);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the real component of\n * an input real number unless it exceeds a maximum value. If it exceeds the\n * maximum value then it sets the output real component to that maximum value.\n * The maximum value is specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealArcsech.java~INTERFACE=Arcsech~BODY=@Override\npublic O compute(I x, O output) {\n    double xt = x.getRealDouble();\n    double numer = 1 + Math.sqrt(1 - xt * xt);\n    double value = Math.log(numer / xt);\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse hyperbolic\n * secant of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealUniformRandom.java~INTERFACE=UniformRandom~BODY=private Random rng = new Random();\n@Override\npublic O compute(I x, O output) {\n    double r = rng.nextDouble();\n    double value = r * x.getRealDouble();\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to a random value between\n * 0 and (input real number).\n * \n * @author Barry DeZonia\n */\n~IMPORTS=import java.util.Random;\n
RealArccosh.java~INTERFACE=Arccosh~BODY=@Override\npublic O compute(I x, O output) {\n    double xt = x.getRealDouble();\n    double delta = Math.sqrt(xt * xt - 1);\n    if (xt <= -1) delta = -delta;\n    double value = Math.log(xt + delta);\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse hyperbolic\n * cosine of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealArccoth.java~INTERFACE=Arccoth~BODY=@Override\npublic O compute(I x, O output) {\n    double xt = x.getRealDouble();\n    double value = 0.5 * Math.log((xt + 1) / (xt - 1));\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse hyperbolic\n * cotangent of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealMultiplyConstant.java~INTERFACE=MultiplyConstant~BODY=private final double constant;\npublic RealMultiplyConstant(double constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    double value = x.getRealDouble() * constant;\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the multiplication of\n * the real component of an input real number with a constant value. The\n * constant value is specified in the constructor.\n *\n * @author Barry DeZonia\n */\n~IMPORTS= 
RealTan.java~INTERFACE=Tan~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.tan(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the tangent of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealStep.java~INTERFACE=Step~BODY=@Override\npublic O compute(I x, O output) {\n    if (x.getRealDouble() < 0) output.setZero(); else output.setOne();\n    return output;\n}\n~JAVADOC=/**\n * Sets an output real number to 0 if the input real number is less than 0.\n * Otherwise sets the output real number to 1. This implements a step function\n * similar to Mathematica's unitstep function. It is a Heaviside step function\n * with h(0) = 1 rather than 0.5.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealAddConstant.java~INTERFACE=AddConstant~BODY=private final double constant;\npublic RealAddConstant(double constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    double value = x.getRealDouble() + constant;\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the addition of\n * the real component of an input real number with a constant value. The\n * constant value is specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealNegate.java~INTERFACE=Negate~BODY=@Override\npublic O compute(I x, O output) {\n    double value = -x.getRealDouble();\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the negation of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealArctan.java~INTERFACE=Arctan~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.atan(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse tangent of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealReciprocal.java~INTERFACE=Reciprocal~BODY=private final double dbzVal;\npublic RealReciprocal(double dbzVal) {\n    this.dbzVal = dbzVal;\n}\n@Override\npublic O compute(I x, O output) {\n    double inputVal = x.getRealDouble();\n    if (inputVal == 0) output.setReal(dbzVal); else output.setReal(1.0 / inputVal);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the reciprocal of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealSubtractConstant.java~INTERFACE=SubtractConstant~BODY=private final double constant;\npublic RealSubtractConstant(double constant) {\n    this.constant = constant;\n}\n@Override\npublic O compute(I x, O output) {\n    double value = x.getRealDouble() - constant;\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the subtraction from\n * the real component of an input real number a constant value. The constant\n * value is specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealSech.java~INTERFACE=Sech~BODY=@Override\npublic O compute(I x, O output) {\n    double value = 1.0 / Math.cosh(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the hyperbolic secant\n * of the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealInvert.java~INTERFACE=Invert~BODY=private double specifiedMin;\nprivate double specifiedMax;\n/**\n	 * Constructor.\n	 * @param specifiedMin - minimum value of the range to invert about\n	 * @param specifiedMax - maximum value of the range to invert about\n	 */\npublic RealInvert(final double specifiedMin, final double specifiedMax) {\n    this.specifiedMax = specifiedMax;\n    this.specifiedMin = specifiedMin;\n}\n@Override\npublic O compute(I x, O output) {\n    double value = specifiedMax - (x.getRealDouble() - specifiedMin);\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inversion of\n * the real component of an input real number about a range. The range is\n * specified in the constructor.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealArcsin.java~INTERFACE=Arcsin~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.asin(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the inverse sine of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealCeil.java~INTERFACE=Ceil~BODY=@Override\npublic O compute(I x, O output) {\n    output.setReal(Math.ceil(x.getRealDouble()));\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the ceiling of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealCubeRoot.java~INTERFACE=CubeRoot~BODY=@Override\npublic O compute(I x, O output) {\n    output.setReal(Math.cbrt(x.getRealDouble()));\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the cube root of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
RealCos.java~INTERFACE=Cos~BODY=@Override\npublic O compute(I x, O output) {\n    double value = Math.cos(x.getRealDouble());\n    output.setReal(value);\n    return output;\n}\n~JAVADOC=/**\n * Sets the real component of an output real number to the cosine of\n * the real component of an input real number.\n * \n * @author Barry DeZonia\n */\n~IMPORTS= 
